# トレードオフ課題 改善提案書

## 現状の課題

### 現行サンプルの問題点

| サンプル | 問題点 |
|---------|--------|
| 三角関数LUT | 効果が体感しにくい。現代CPUでは三角関数は高速で、差が見えにくい |
| 可視性マップ | 初期化に時間がかかる（50×50グリッドで数秒）。動的環境に不向き |

### 求められる条件

1. **効果が分かりやすい** - Profilerで明確な差が見える
2. **初期化が軽い** - ゲーム開始時に待たされない
3. **ゲームに直結** - 無双ゲームの文脈で意味がある
4. **実装が適度** - 15分で実装可能な複雑さ

---

## 提案サンプル

### 提案1: 近傍キャッシュ（Neighbor Cache）⭐推奨

#### 概要
各敵の「近くにいる敵リスト」を一定時間キャッシュし、毎フレームの検索を避ける。

#### トレードオフ
| 項目 | 値 |
|------|-----|
| メモリ増加 | 敵1体あたり約200バイト（List + 参照×20体） |
| CPU削減 | 近傍検索を1/10に削減（10フレームキャッシュ時） |
| 精度低下 | 最大10フレーム分の位置ズレ |

#### 使用場面（無双ゲーム）
- 敵同士の衝突回避（分離行動）
- 群れ行動の計算
- 包囲時の間隔調整

#### なぜ効果的か
- 500体の敵がいる場合、毎フレーム500×500=25万回の距離計算が必要
- キャッシュにより2.5万回に削減（10倍高速化）
- Profilerで明確にCPU時間が減少する

#### 実装の複雑さ
- Dictionary<Enemy, CacheData> でキャッシュ管理
- CacheData = List<Enemy> + lastUpdateFrame
- 15分で実装可能

---

### 提案2: AI判断キャッシュ（Decision Cache）

#### 概要
敵のAI判断結果（追跡/攻撃/待機）を数フレーム保持し、毎フレームの判断処理を削減。

#### トレードオフ
| 項目 | 値 |
|------|-----|
| メモリ増加 | 敵1体あたり約16バイト（状態 + タイムスタンプ） |
| CPU削減 | AI判断を1/5に削減（5フレームキャッシュ時） |
| 応答性低下 | 最大5フレーム分の反応遅延 |

#### 使用場面（無双ゲーム）
- 敵の状態遷移判定
- プレイヤー検知判定
- 攻撃タイミング判定

#### なぜ効果的か
- AI判断には距離計算、状態チェック、乱数などが含まれる
- これらを毎フレーム全敵で実行するのは重い
- キャッシュで「同じ判断を繰り返す」コストを削減

---

### 提案3: 攻撃対象キャッシュ（Target Cache）

#### 概要
プレイヤーの攻撃範囲内にいる敵リストを一定間隔でキャッシュ。

#### トレードオフ
| 項目 | 値 |
|------|-----|
| メモリ増加 | 約400バイト（List + 参照×50体） |
| CPU削減 | 攻撃時の範囲検索を大幅削減 |
| 精度低下 | キャッシュ間隔分のヒット判定ズレ |

#### 使用場面（無双ゲーム）
- プレイヤーの攻撃ヒット判定
- 範囲攻撃のダメージ計算
- コンボ対象の決定

---

## 推奨構成

### メイン課題として
1. **近傍キャッシュ** - 最も効果が分かりやすく、実装も適度

### サブ課題として（時間があれば）
2. **AI判断キャッシュ** - メモリ使用量が少なく、効果も大きい

### 既存課題の扱い
- **TrigLUT**: 発展課題として残す（理論的理解のため）
- **可視性マップ**: 削除または発展課題に移動

---

## 実装設計：近傍キャッシュ

### クラス設計

```csharp
public class NeighborCache_Exercise : MonoBehaviour
{
    // キャッシュデータ構造
    private struct CacheEntry
    {
        public List<Enemy> Neighbors;
        public int LastUpdateFrame;
    }

    // キャッシュ本体
    private Dictionary<Enemy, CacheEntry> _cache;

    // 設定
    private int _cacheLifetimeFrames = 10;  // キャッシュ有効期間
    private float _neighborRadius = 5f;      // 近傍判定距離

    // メソッド
    public List<Enemy> GetNeighbors(Enemy enemy);  // キャッシュから取得
    public void UpdateCache(Enemy enemy);          // キャッシュを更新
    public void ClearCache();                      // キャッシュをクリア
}
```

### 穴埋め課題の設計

```csharp
/// <summary>
/// 近傍の敵を取得する（キャッシュ使用）
/// </summary>
public List<Enemy> GetNeighbors(Enemy enemy)
{
    // TODO: 以下を実装してください
    // 1. キャッシュにエントリがあるかチェック
    // 2. キャッシュが有効期間内かチェック（frameCount - lastUpdate < lifetime）
    // 3. 有効なら cached.Neighbors を返す
    // 4. 無効なら UpdateCache() を呼んで新しいリストを返す

    // 仮実装（毎回計算 - 問題あり）
    return CalculateNeighbors(enemy);
}
```

### 学生が学ぶこと
1. キャッシュの基本概念（有効期間、更新タイミング）
2. メモリと計算のトレードオフ
3. 「いつキャッシュを使うべきか」の判断基準

---

## 実装設計：AI判断キャッシュ

### クラス設計

```csharp
public class DecisionCache_Exercise : MonoBehaviour
{
    // キャッシュデータ構造
    private struct DecisionEntry
    {
        public EnemyAIState CachedState;
        public Vector3 CachedTarget;
        public int DecisionFrame;
    }

    // キャッシュ本体
    private Dictionary<Enemy, DecisionEntry> _decisions;

    // 設定
    private int _decisionLifetimeFrames = 5;

    // メソッド
    public EnemyAIState GetCachedDecision(Enemy enemy, out Vector3 target);
    public void CacheDecision(Enemy enemy, EnemyAIState state, Vector3 target);
}
```

---

## 考察課題（改訂版）

### Q1: キャッシュの有効期間を長くするとどうなるか？

**期待される回答**:
- メモリ使用量: 変化なし（エントリ数は同じ）
- CPU負荷: さらに削減（更新頻度が下がる）
- 精度: 低下（古い情報で判断するリスク）

### Q2: 敵が1000体の場合、近傍キャッシュのメモリ使用量は？

**期待される回答**:
- 1体あたり: List参照(8byte) + 要素(20体×8byte) + フレーム(4byte) = 約172byte
- 1000体: 約172KB
- 評価: 現代のPCでは問題ない量

### Q3: キャッシュを使うべき場面と使わない方が良い場面は？

**期待される回答**:

使うべき場面:
- 計算コストが高い処理
- 結果が短期間で大きく変わらない
- 多少の遅延が許容される

使わない方が良い場面:
- 計算が軽い処理
- リアルタイム性が重要（ヒット判定など）
- メモリが厳しい環境

---

## 時間配分（改訂案）

| 時間 | 内容 |
|------|------|
| 0-5分 | キャッシュの概念説明 |
| 5-20分 | 近傍キャッシュ実装 |
| 20-25分 | Profilerで効果確認 |
| 25-30分 | 考察課題 |

---

## 期待される計測結果

### 近傍キャッシュ

| 敵の数 | キャッシュなし | キャッシュあり | 改善率 |
|--------|---------------|---------------|--------|
| 200体 | 8ms | 2ms | 4x |
| 500体 | 45ms | 8ms | 5.6x |
| 1000体 | 180ms | 25ms | 7.2x |

※敵の数が多いほど効果が大きい

---

## 結論

### 採用推奨
1. **近傍キャッシュ** をメインのトレードオフ課題として採用
2. **AI判断キャッシュ** をオプション課題として追加

### 既存課題の扱い
- TrigLUT: 「発展課題」セクションに移動
- 可視性マップ: 削除（初期化時間の問題が大きすぎる）

### 理由
- 効果が明確（Profilerで5-7倍の改善が見える）
- 実装が適度（15分で完成可能）
- ゲームに直結（群れ行動の計算に直接使用）
- メモリ増加が可視化しやすい（172KB/1000体）
