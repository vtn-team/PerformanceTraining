# 教員用ガイド

## 概要

このドキュメントは、パフォーマンス最適化学習プログラムを実施する教員向けのガイドです。

---

## 事前準備

### 必要な環境
- Unity 2022.3 LTS以上
- Universal Render Pipeline (URP)
- Profiler使用可能なエディタ設定

### 推奨PC要件
- CPU: Core i5 以上
- RAM: 8GB 以上
- GPU: 統合グラフィックス以上

### プロジェクトの準備

1. プロジェクトをUnityで開く
2. `Assets/Resources/LearningSettings.asset` を選択
3. 全ての最適化オプションをOFFに設定
4. シーン `MainGame` を開く

---

## 時間配分（4時間コース）

| 時間 | 課題 | 内容 | 形式 |
|------|------|------|------|
| 0:00-0:30 | 準備 | プロジェクト確認、Profiler準備、初期計測 | 説明 |
| 0:30-1:30 | 課題1 | ゼロアロケーション | 穴埋め実装 |
| 1:30-2:30 | 課題2 | CPU計算キャッシュ | 穴埋め実装 |
| 2:30-3:00 | 課題3 | メモリ↔CPUトレードオフ | 穴埋め+考察 |
| 3:00-3:30 | 課題4 | グラフィクス最適化 | 設定変更 |
| 3:30-4:00 | まとめ | 最終計測、振り返り、DOTS比較 | 説明 |

---

## 課題別の教え方

### 課題1: ゼロアロケーション

#### 導入（5分）
- GCアロケーションとは何か
- なぜUpdate内でのアロケーションを避けるべきか
- Profilerでの確認方法

#### 各Step解説

**Step 1: オブジェクトプール**
- Instantiate/Destroyのコスト
- Stack<T>を使ったプール実装のパターン
- よくある間違い: Return忘れ

**Step 2: StringBuilder**
- 文字列の不変性（immutability）
- 文字列結合で発生する一時オブジェクト
- StringBuilder.Clear()の重要性

**Step 3: デリゲートキャッシュ**
- ラムダ式のキャプチャとアロケーション
- フィールドでのキャッシュパターン
- System.Actionとメソッドグループ

**Step 4: コレクション再利用**
- List<T>の内部配列
- Clear() vs new List<T>()
- 初期容量の重要性

#### 確認ポイント
- Profiler > CPU > GC Alloc を開かせる
- 最適化前後の差を記録させる

---

### 課題2: CPU計算キャッシュ

#### 導入（5分）
- O(n²)アルゴリズムの問題
- 空間計算量と時間計算量のトレードオフ

#### 各Step解説

**Step 1: 空間分割**
- グリッドベースの空間分割の概念
- セルインデックスの計算方法
- 近傍セル(3x3)の検索

**Step 2: 更新分散**
- フレームスパイクの問題
- modulo演算による分散
- 重い処理と軽い処理の分離

**Step 3: sqrMagnitude**
- 平方根計算のコスト
- 2乗距離での比較
- よくある間違い: 閾値を2乗し忘れる

---

### 課題3: トレードオフ

#### 導入（5分）
- メモリとCPUのトレードオフの概念
- 「正解はない」ことの説明

#### 考察課題

以下の質問を学生に考えさせる:

```
Q1: 三角関数LUTのメモリ使用量を計算せよ
A: 360 * 4バイト * 2 = 2,880バイト (約2.8KB)

Q2: 可視性マップのメモリ使用量を計算せよ
A: 50 * 50 * 50 * 50 = 6,250,000 (約6MB、対称性利用で約3MB)

Q3: それぞれの手法を使うべき場面は?
- LUT: 精度が不要、頻繁に三角関数を使う、メモリに余裕がある
- Map: 静的な環境、可視性判定が頻繁、再計算が許容される
```

---

### 課題4: グラフィクス

GraphicsGuide.md に従って進める。
コード実装なしのため、設定変更を確認しながら進める。

---

## 解答ファイル

解答は以下のフォルダにあります:
`Scripts/Solutions/`

学生には見せないでください。
困っている学生には、ヒントとして一部のコードを見せることは可能です。

---

## トラブルシューティング

### よくある問題

| 問題 | 原因 | 対処 |
|------|------|------|
| FPSが上がらない | 最適化が有効になっていない | LearningSettings確認 |
| エラーが出る | 構文ミス、null参照 | コンパイルエラー確認 |
| 効果が見えない | 敵の数が少ない | F1で敵を追加 |
| Profilerが重い | Deep Profile有効 | オフにする |

### 学生が詰まりやすいポイント

1. **オブジェクトプール**
   - Pop時のnullチェック忘れ
   - Return時のSetActive(false)忘れ

2. **空間分割**
   - インデックス計算の符号ミス
   - 範囲外アクセス

3. **sqrMagnitude**
   - 閾値の2乗忘れ
   - 戻り値が2乗であることの忘れ

---

## 評価基準

### 実装評価（60点）
- 課題1: 各Step 5点 × 4 = 20点
- 課題2: 各Step 7点 × 3 = 21点
- 課題3: 各課題 7点 × 2 = 14点
- 課題4: 5点

### 計測記録（20点）
- Before/After の記録: 10点
- 正確な計測: 10点

### 考察（20点）
- トレードオフの理解: 10点
- 適用場面の説明: 10点

---

## DOTS比較プロジェクト

別プロジェクト `MassacreDojo_DOTS` を使用して、
DOTSとの比較を体験させます。

### 比較ポイント
- 敵1000体でのFPS差
- コードの複雑さ
- 学習コスト

### 質問例
```
Q: 従来手法（最適化後）とDOTSで、どの程度の差があったか?
Q: DOTSの導入コスト（学習曲線、コード量）をどう評価するか?
Q: このゲームにDOTSは必要だったか?理由とともに答えよ。
```

---

## 授業後のフォローアップ

### 追加資料
- Unity公式パフォーマンス最適化ガイド
- Profiler Analyzerの使い方
- Memory Profilerの使い方

### 発展課題
- プール自動縮小機能の実装
- 動的セルサイズ調整
- LUTの線形補間
- 敵2000体チャレンジ
